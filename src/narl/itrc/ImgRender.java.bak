package narl.itrc;

import java.util.concurrent.atomic.AtomicInteger;

import com.sun.glass.ui.Application;

import javafx.application.Platform;
import javafx.concurrent.Task;
import javafx.scene.image.Image;

public class ImgRender {
	
	private ImgControl ctrl = null;
	private ImgPreview[] prvw = null;
	private CamBundle[] bund = null;
	private Image[] buff = null;
	
	public ImgRender(){
	}
	
	public ImgRender(ImgControl control){
		ctrl = control;
	}
	
	public ImgRender(ImgPreview... preview){
		prvw = preview;
	}
	
	public ImgRender(ImgControl control,ImgPreview... preview){
		ctrl = control;
		prvw = preview;
	}
	
	public void setPreview(ImgPreview... preview){
		prvw = preview;
	}
	
	public ImgPreview[] getPreview(){
		return prvw;
	}
	
	public CamBundle getBundle(){
		return (bund==null)?(null):(bund[0]);
	}	
	public CamBundle getBundle(int idx){
		if(bund==null){
			return null;
		}
		if(idx>=bund.length){
			return null;
		}
		return bund[idx];
	}
	
	private void initBundle(){
		bund = new CamBundle[prvw.length];
		for(int i=0; i<prvw.length; i++){
			bund[i] = prvw[i].bundle;
		}
		buff = new Image[prvw.length];
	}
	
	private Task<Integer> task = null;
	/**
	 *  User must call "cancel()" to release camera!!! 
	 */	
	public void launch(){
		if(isWorking()==true){
			return;
		}
		initBundle();
		task = new Task<Integer>(){
			@Override
			protected Integer call() throws Exception {
				if(bund==null){ 
					return -1;//WTF???
				}				
				//stage.1 - try to open camera~~~
				if(bundSetup()==0){
					return -2;//no camera!!!
				}
				flagWait.set(0);
				
				//stage.2 - continue to grab image from camera			
				while(isLive()==true){
					
					if(ctrl!=null){
						//check whether we need to play video~~~
						if(ctrl.btnPlayer.getState()==false){
							Thread.sleep(50);
							continue;
						}
					}
					
					if(flagWait.get()!=0){
						flagWait.set(2);
						Thread.sleep(60000);
						continue;
					}
					
					bundFetch();
					if(Application.GetApplication()==null){						
						break;//Platform is shutdown
					}
					for(ImgPreview pp:prvw){
						doAction(pp);
					}
					eventFilter();//process image and show data~~~
					
					Platform.runLater(eventShow);
				}
				return 0;
			}
		};
		task.setOnScheduled(EVENT->{
			for(ImgPreview pp:prvw){
				pp.initScreen(ImgRender.this);
			}
		});
		task.setOnCancelled(EVENT->{
			Misc.logv("Render cancel");
			bundClose();
		});
		new Thread(task,"imgRender").start();
	}

	public void cancel(){
		if(isWorking()==false){
			return;
		}
		task.cancel();
	}

	private int bundSetup(){
		int cnt = bund.length;
		for(int i=0; i<bund.length; i++){
			if(bund[i]==null){
				continue;
			}
			bund[i].resetMark();
			bund[i].syncSetup();
			if(bund[i].optEnbl.get()==false){				
				bund[i] = null;//reset this~~~
				cnt--;
			}
		}
		return cnt;
	}

	private void bundFetch(){
		for(int i=0; i<bund.length; i++){
			if(bund[i]==null){
				buff[i] = null;				
			}else{
				bund[i].fetch();
				bund[i].markData();
				buff[i] = bund[i].getImage(1);//show overlay~~
			}
		}
	}
	
	private void bundClose(){
		for(CamBundle b:bund){
			if(b!=null){
				b.close();
			}			
		}
	}
	
	/**
	 * Really "render" screen and this interface is executed by GUI thread.<p>
	 */
	private Runnable eventShow = new Runnable(){
		@Override
		public void run() {
			for(int i=0; i<prvw.length; i++){
				if(prvw[i]==null){
					continue;
				}
				if(buff[i]==null){
					continue;
				}
				prvw[i].screen.setImage(buff[i]);
			}
		}
	};

	public boolean isWorking(){
		if(task==null){
			return false;
		}
		return task.isRunning();
	}
	
	private boolean isLive(){
		//First,check user cancel task~
		if(task.isCancelled()==true){
			return false;
		}
		//Second,check all camera are live~
		for(CamBundle b:bund){
			if(b!=null){
				if(b.optEnbl.get()==true){
					return true;
				}
			}			
		}
		return false;//no camera, we can stop working :-)
	}
	
	private AtomicInteger flagWait = new AtomicInteger(0);
	public void sleep(){
		flagWait.set(1);
		//while(flagWait.get()==1);
	}	
	public synchronized void invoke(){
		//if(flagWait.get()!=2){ return; }
		flagWait.set(0);
		Thread.interrupted();
	}
	
	private SNDir dirSnap = new SNDir(Misc.pathTemp,"snap%.png");
	
	private void doAction(ImgPreview pp){
		switch(pp.action.get()){
		case ImgPreview.ACT_SNAP:{
			Misc.imWrite(
				dirSnap.genSNTxt(),
				pp.bundle.getMatSrc()
			);
			/*int[] zone={0,0,0,0};
			if(bundle.getROI(0,zone)==true){
				Misc.imWriteX(
					Misc.pathTemp+"roi.png",
					pp.bundle.getMatSrc(),
					zone
				);
			}*/
			pp.action.set(ImgPreview.ACT_NONE);			
			Application.invokeAndWait(new Runnable(){
				@Override
				public void run() {
					PanBase.msgBox.notifyInfo(
						"Snap",
						"儲存成 "+Misc.trimPath(dirSnap.getSNTxt())
					);
				}
			});
			}break;
		case ImgPreview.ACT_RECD:{
			}break;
		}
	}	
	//---------------------//
	
	public interface Filter{
		/**
		 * this invoked by controller(GUI thread)<p>
		 * user can prepare data or check any required objects
		 * @param rnd - the object of image-render
		 * @return 
		 * 	true - we done<p>
		 * 	false- ready, go to next stage<p> 
		 */
		abstract boolean initData(ImgRender rndr);
		/**
		 * this invoked by render-thread<p>
		 * user can process or cook data here<p>
		 * @param bnd - camera bundle
		 * @return 
		 * 	true - we done<p>
		 * 	false- ready, go to next turn<p> 
		 */
		abstract boolean cookData(CamBundle[] bnd);//this invoked by render-thread
		/**
		 * this invoked by GUI thread<p>
		 * user can show charts or change the state of widget here<p>
		 * @param bnd - camera bundle
		 * @return 
		 * 	true - we done<p>
		 * 	false- ready, go to next turn<p> 
		 */
		abstract boolean showData(CamBundle[] bnd);//this invoked by GUI thread
	}
	private Filter fltrObj = null;
	
	private void eventFilter(){
		if(fltrObj==null){
			return;
		}
		boolean done = fltrObj.cookData(bund);
		Application.invokeAndWait(()->{
			if(fltrObj==null){
				return;
			}
			if(fltrObj.showData(bund)==true){
				fltrObj=null;
			}
		});
		if(done==true){
			fltrObj=null;
		}
	}
		
	public void hookFilter(Filter obj){
		//this method must be invoked by GUI thread~~~
		if(fltrObj!=null){
			PanBase.msgBox.notifyWarning("Render","忙碌中...");
			return;
		}
		if(obj.initData(this)==true){
			return;
		}
		fltrObj = obj; 
	}	
}
