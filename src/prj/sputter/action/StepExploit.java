package prj.sputter.action;

import java.util.ArrayDeque;
import java.util.ArrayList;

import org.apache.commons.math3.random.RandomVectorGenerator;
import org.apache.commons.math3.random.SobolSequenceGenerator;
import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics;

import javafx.geometry.Orientation;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.control.Separator;
import javafx.scene.control.TextField;
import javafx.scene.layout.GridPane;
import narl.itrc.Misc;

//實驗用步驟~~~
public class StepExploit extends Bumper {
	
	public static final String TXT_EXPLOIT = "資料探勘";
	
	public StepExploit() {
		for(TextField obj:box) {
			obj.getStyleClass().add("font-console");
			obj.setMaxWidth(100.);
		}
		for(Label obj:inf) {
			obj.getStyleClass().add("font-console");
			obj.setMinWidth(100.);
		}
		set(op0,op1,op2,op3,op4,op5,op6);
	}

	final Label[] inf = {
		//title and information
		new Label(), 
		new Label(), 
		new Label(), 
		new Label(),
		//current setting value
		new Label(), 
		new Label(), 
		new Label(),
	};
	final TextField[] box = {
		//power generator
		new TextField("500"),
		new TextField("300"),
		new TextField("10"),
		//mass flow - Ar
		new TextField("30"),
		new TextField("20"),
		new TextField("5"),
		//mass flow - O2
		new TextField("10"),
		new TextField("5"),
		new TextField("5"),
	};
	
	final TextField max_pw = box[0];
	final Label     cur_pw = inf[4];
	final TextField min_pw = box[1];
	final TextField stp_pw = box[2];
	
	final TextField max_ar = box[3];
	final Label     cur_ar = inf[5];
	final TextField min_ar = box[4];	
	final TextField stp_ar = box[5];
	
	final TextField max_o2 = box[6];
	final Label     cur_o2 = inf[6];
	final TextField min_o2 = box[7];
	final TextField stp_o2 = box[8];

	final DescriptiveStatistics stat_rate = new DescriptiveStatistics(20);
	
	class ValPack {

		int[] x = {0, 0, 0,};//pw, Ar, O2
		float y1, y2;
		
		ValPack(double... val){
			x[0] = scale_value(val[0],min_pw,max_pw);
			x[1] = scale_value(val[1],min_ar,max_ar);
			x[2] = scale_value(val[2],min_o2,max_o2);
		}
		ValPack setY(double avg, double dev) {
			y1 = (float)avg;
			y2 = (float)dev;
			return this;
		}
		int scale_value(
			final double val, 
			final TextField box_min,
			final TextField box_max
		) {
			final float max = Float.valueOf(box_max.getText().trim());
			final float min = Float.valueOf(box_min.getText().trim());				
			return (int)((max-min)*val+min);
		}
		String txt_power()  { return String.valueOf(x[0]); }
		String txt_mass_Ar(){ return String.valueOf(x[1]); }
		String txt_mass_O2(){ return String.valueOf(x[2]); }
	};
	final ArrayList<ValPack>  s_pooler = new ArrayList<ValPack>();
	final ArrayDeque<ValPack> s_queuer = new ArrayDeque<ValPack>();
	final RandomVectorGenerator gen = new SobolSequenceGenerator(3);
	
	long tick_beg;		
	ValPack best_pck = null;		
	final Runnable op0 = ()->{
		tick_beg = System.currentTimeMillis();			
		best_pck = null;
		inf[0].setText("Exploit");
		inf[1].setText("");
		inf[2].setText("");
		inf[3].setText("");
		next_step();
	};
	
	final Runnable op1 = ()->{
		//prepare and reset data
		s_pooler.clear();			
		for(int i=0; i<60; i++) {
			final double[] val = gen.nextVector();				
			s_queuer.add(new ValPack(val));
		}
		next_step();
	};
	
	final Runnable op2 = ()->{
		//initialize all variables
		final ValPack pck = s_queuer.getFirst();
		cur_pw.setText(pck.txt_power());
		cur_ar.setText(pck.txt_mass_Ar());
		cur_o2.setText(pck.txt_mass_O2());
		dcg1.asyncSetWatt(
			cur_pw.getText().trim()
		);
		coup.asyncSetMassFlow(
			cur_ar.getText().trim(), 
			"", 
			cur_o2.getText().trim()
		);
		stat_rate.clear();
		next_step();
	};
	
	final Runnable op3 = ()->{
		if(spik.ARC_count.get()>=10) {
			inf[1].setText("!!電弧!!");
			hold_step();
			return;
		}
		inf[1].setText("等待中");
		inf[2].setText("");
		inf[3].setText("");
		if(waiting_time(5*1000)>0) {
			return;//等待氣體穩定~~~			
		};
	};
	
	final Runnable op4 = ()->{
		
		stat_rate.addValue(sqm1.meanRate.get());			
		
		final int nn = (int)stat_rate.getN();
		final int ww = stat_rate.getWindowSize();
		inf[1].setText("統計中");
		inf[2].setText(String.format(
			"%4.2f s %.3f",
			stat_rate.getMean(),
			stat_rate.getStandardDeviation()
		));
		inf[3].setText(String.format(
			"%d/%d",
			nn,ww
		));			
		if(nn<ww) {
			hold_step();
			return;
		}

		final double avg = stat_rate.getMean();
		final double dev = stat_rate.getStandardDeviation();
		
		s_pooler.add(s_queuer.pollFirst().setY(avg,dev));
		
		Misc.logv(
			"%s: "+
			"%s W, %s sccm, %s sccm, "+
			"%s, %s ", 
			TXT_EXPLOIT,
			cur_pw.getText(), cur_ar.getText(), cur_o2.getText(),
			String.format("%5.2f",avg), String.format("%5.3f",dev) 
		);
		if(s_queuer.isEmpty()==true) {
			next_step();
		}else {
			next_step(-2);
		}			
	};

	final Runnable op5 = ()->{
		//make decision~~~~
		//find outline value(use min and max)~~~
		
		ValPack min,max;
		min = max = s_pooler.get(0);
		for(int i=1; i<s_pooler.size(); i++) {
			ValPack p = s_pooler.get(i);
			if(max.y1<p.y1) {
				max = p;
			}
			if(p.y1<min.y1) {
				min = p;
			}
		}
		best_pck = max;
		
		if(Math.abs(max.y1-min.y1)<0.1) {
			//distribution is too uniform, stop process~~~
			next_step();
		}else {
			//generate distribution again!!
			next_step(-4);
		}			
	};
	
	final Runnable op6 = ()->{
		long tick_diff = System.currentTimeMillis() - tick_beg;
		inf[0].setText("Done");
		inf[1].setText(Misc.tick2text(tick_diff,true));
		inf[2].setText("");
		inf[3].setText("");
		cur_pw.setText(best_pck.txt_power());
		cur_ar.setText(best_pck.txt_mass_Ar());
		cur_o2.setText(best_pck.txt_mass_O2());
		next_step();
	};
	
	@Override
	public Node getContent() {
		final GridPane lay = new GridPane();
		lay.getStyleClass().addAll("box-pad","font-console");
		lay.addColumn(0, inf[0], inf[1], inf[2], inf[3]);
		lay.add(new Separator(Orientation.VERTICAL), 1, 0, 1, 4);
		lay.addColumn(2,
			new Label(),
			new Label("最大"),
			new Label("SV" ),
			new Label("最小"),
			new Label("修正")
		);
		lay.addColumn(3,
			new Label("功率(watt)"), max_pw, cur_pw, min_pw, stp_pw
		);
		lay.addColumn(4,
			new Label("Ar (sccm)"), max_ar, cur_ar, min_ar, stp_ar
		);
		lay.addColumn(5,
			new Label("O2 (sccm)"), max_o2, cur_o2, min_o2, stp_o2
		);
		// "速率(Å/s ):"
		return lay;
	}
	@Override
	public void eventEdit() {
	}
	@Override
	public String flatten() {
		return "";
	}
	@Override
	public void expand(String txt) {
	}
}
